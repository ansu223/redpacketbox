# Telegram Bot with Mini Game and Ads Integration

import os
import logging
import random
from aiogram import Bot, Dispatcher, types
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.utils import executor

TOKEN = "YOUR_BOT_TOKEN"
ADMIN_ID = "YOUR_ADMIN_ID"

bot = Bot(token=TOKEN)
dp = Dispatcher(bot)

logging.basicConfig(level=logging.INFO)

# User balances storage (for demonstration, use a database in production)
user_balances = {}

# Start command
@dp.message_handler(commands=['start'])
async def start(message: types.Message):
    user_id = message.from_user.id
    user_balances.setdefault(user_id, 0)
    keyboard = InlineKeyboardMarkup()
    keyboard.add(InlineKeyboardButton("Spin & Win ğŸ°", callback_data="spin_game"))
    await message.answer("ğŸ Welcome to RedPacket Bot! Spin the wheel to earn BTTC!", reply_markup=keyboard)

# Spin Game Handler
@dp.callback_query_handler(lambda c: c.data == "spin_game")
async def spin_game(callback_query: types.CallbackQuery):
    user_id = callback_query.from_user.id
    prizes = [10, 50, 100, 500, 1000, 0]
    reward = random.choice(prizes)
    user_balances[user_id] += reward
    message = f"ğŸ¡ You spun the wheel and won {reward} BTTC!\nğŸ’° Your balance: {user_balances[user_id]} BTTC"
    await bot.answer_callback_query(callback_query.id)
    await bot.send_message(user_id, message)

# Balance Check
@dp.message_handler(commands=['balance'])
async def balance(message: types.Message):
    user_id = message.from_user.id
    balance = user_balances.get(user_id, 0)
    await message.answer(f"ğŸ’° Your balance: {balance} BTTC")

# Ads Integration (Placeholder for actual ad reward system)
@dp.message_handler(commands=['watch_ad'])
async def watch_ad(message: types.Message):
    user_id = message.from_user.id
    user_balances[user_id] += 50  # Reward for watching an ad
    await message.answer(f"ğŸ“º Thanks for watching the ad! You've earned 50 BTTC!\nğŸ’° New balance: {user_balances[user_id]} BTTC")

# Run bot
if __name__ == "__main__":
    executor.start_polling(dp, skip_updates=True)
